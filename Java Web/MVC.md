
[Java Web开发教程——基本思路](https://zhuanlan.zhihu.com/p/20756940)|[浅析MVC模式与三层架构的区别](https://www.cnblogs.com/rainbow70626/p/4967478.html)|[从 MVC 到前后端分离 ](https://my.oschina.net/huangyong/blog/521891)|
---|---|---|

[MVC，MVP 和 MVVM 的图示](https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)|[一篇文章了解前端框架演变](https://segmentfault.com/a/1190000015051472)|[界面之下：还原真实的MV*模式](https://github.com/livoras/blog/issues/11)|[前端MVC变形记](https://efe.baidu.com/blog/mvc-deformation/)|
---|---|---|---|

* [MVC模式](#MVC模式)
  * 前端MVC模式
  * 后端MVC模式
    * [经典的后端 MVC 模式](#经典的后端-MVC-模式)
      * [经典的后端 MVC 模式的缺点](#经典的后端-MVC-模式的缺点)
    * [后端 WEB MVC 模式的变体 Model1模式](#后端-WEB-MVC-模式的变体-Model1模式)
    * [后端 WEB MVC 模式的变体 Model2模式](#后端-WEB-MVC-模式的变体-Model2模式)
  
  
# MVC模式

## 经典的后端 MVC 模式

<a href="https://ibb.co/ZYgpXMY"><img src="https://i.ibb.co/b2vMmK2/mvc.png" alt="mvc" border="0"></a>

最初是应用在GUI程序（图形界面程序）上，只是解决客户端图形界面应用程序的问题，而对WEB服务端无效，我们称之为经典MVC，

**MVC的调用关系**

用户的对View操作以后，View捕获到这个操作，会把处理的权利交移给Controller（Pass calls）；Controller会对来自View数据进行预处理、决定调用哪个Model的接口；然后由Model执行相关的业务逻辑；当Model变更了以后，会通过观察者模式（Observer Pattern）通知View；View通过观察者模式收到Model变更的消息以后，会向Model请求最新的数据，然后重新更新界面

看似没有什么特别的地方，但是由几个需要特别关注的关键点：

1） View是把控制权交移给Controller，Controller执行应用程序相关的应用逻辑（对来自View数据进行预处理、决定调用哪个Model的接口等等）。
2） Controller操作Model，Model执行业务逻辑对数据进行处理。但不会直接操作View，可以说它是对View无知的。
3） **View和Model的同步消息是通过观察者模式进行，而同步操作是由View自己请求Model的数据然后对视图进行更新。**

需要特别注意的是MVC模式的精髓在于第三点：Model的更新是通过观察者模式告知View的，具体表现形式可以是Pub/Sub或者是触发Events。而网上很多对于MVC的描述都没有强调这一点。**通过观察者模式的好处就是：不同的MVC三角关系可能会有共同的Model，一个MVC三角中的Controller操作了Model以后，两个MVC三角的View都会接受到通知，然后更新自己。保持了依赖同一块Model的不同View显示数据的实时性和准确性。**我们每天都在用的观察者模式，在几十年前就已经被大神们整合到MVC的架构当中。


  **模型**
  
  指应用程序中作为业务逻辑入口点的对象，它包括应用程序的状态和供应视图的数据，模型并通知视图其状态发生了变化并响应来自于视图中的状态变化请求。模型同样将用来执行控制器请求的操作，这些操作通
  常会导致模型中状态的变化。
  
  **视图**
  
  指将要显示给用户的图形化元素的生成，捕获并处理用户操作。视图将用户操作调用转发给控制器，控制器将为用户界面中每个可能发生操作给出一个专门的方法，每个支持的用户操作都对应着控制器上的一个操作，
  控制器将通过执行被触发的操作来更新模型，模型将通知视图其状态发生了变化，最后，视图将决定是否把该变化反映到用户界面上，若需要的话，视图将读取模型，并提供更新后的界面，视图和模型是通过观察者
  模式绑定到一起的，主动方（模型）将在发生变化时通知观察者（视图），随后，视图从模型中读取当前的状态并进行相应的更新
  
  **控制器**
  
  将把用户操作映射程程序操作，并负责选择下一个视图，MVC大多数的工作都在视图和控制  器中，仅仅在视图中需要使用模型中的数据来显示。对于简单的应用程序来说，应
  用MVC模式意味着要创建一个视图，一个控 制器和一个业务层， 但在复杂的应用程序来说，使用MVC模式则用来在表现层中实现分离关注点，成为表现层中的一个模式

### 经典的后端 MVC 模式的缺点

**优点：**

1） 把业务逻辑和展示逻辑分离，模块化程度高。且当应用逻辑需要变更的时候，不需要变更业务逻辑和展示逻辑，只需要Controller换成另外一个Controller就行了（Swappable Controller）。

2） 观察者模式可以做到多视图同时更新。

**缺点：**

1） Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，应用逻辑正确性是无法验证的：Model更新的时候，无法对
    View的更新操作进行断言。

2） View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的Domain Model是不一样的


## 后端 WEB MVC 模式的变体 Model1模式
  
  在WEB程序上的MVC都是经典MVC的变体

## 后端 WEB MVC 模式的变体 Model2模式

<a href="https://ibb.co/djvRbfx"><img src="https://i.ibb.co/0mLxBnv/model2.png" alt="model2" border="0"></a>


  在WEB程序上的MVC都是经典MVC的变体
  Model2是MVC应用到Web这种新邻域的变体，前面说过的经典的MVC也可应用到Web上， 但Model2是更好的选择。

  服务端接收到来自客户端的请求，服务端通过路由规则把这个请求交由给特定的Controller进行处理，Controller执行相应的应用逻辑，对Model进行操作，Model执行业务逻辑以后；然后用数据去渲染特定
  的模版，返回给客户端。




## 后端MVC的优势
   
    1）简化了对用户界面的测试，
    2）将代码从视图中分离开来就意味着修改图形界面不会影响到用户界面的行为，有助于代码更加结构化，并在逻辑上分层
    3）将表现层分为不同的对象可使不同的团队**同时**开发应用程序的不同部份变成了可能，例如 设计师看规划视图，同时开发人员可编写具体操作
   

----

### 路由：
    解决什么样的请求交给哪个后端处理单元处理的问题。

### data binding：
    解决把前端传来的数据（url path、字符串形式的键值对、Header中的信息、cookie中的信息等，必然是字符串）包装为Java可以使用的对象的问题。要实现的效果是，所有需求对于后端业务代码来讲都要是
    透明的，不要再有手动的转换过程。一般的MVC框架都有比较清晰完善的解决方案，但有些边角的需求，需要注意怎样实现更为简便。例如如想传入的信息是三个student，每个student都有name、id两个属相，
    那怎样才能在后端业务代码中直接得到一个List<Student>？

### 模板引擎：
    解决怎样把后端的处理结果转换为html页面显示给前端的问题。首先解决转发给哪个模板，例如使用jsp作为模板引擎，后端处理单元就要做到可以控制跳转到哪个jsp文件。其次是数据显示，后端处理单元处理
    所得到的数据要转化为字符串然后放到html中的相应位置上。需要注意的事如何能透明的对相应数据做格式化显示，如所有日期类信息都以yyyy-MM-dd的格式显示，不需要在任何逻辑控制单元中做手动转换

### Ajax/Json：
    越来越多的请求将以ajax的形式返回给前端。简单来说，需要解决的就是怎样把后端处理的结果透明的转换为Json数据的问题。MVC框架一般都有相应的解决方案，通过简单的声明就可以控制信息以Json形式返回。
    需要注意的是，Model如果不是纯粹的贫血模型，怎样控制每个字段（或get开头的函数）是否要转化为json发给前端。
