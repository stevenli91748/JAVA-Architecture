<details>
<summary>Synchronize实现原理（很难）</summary>
  
synchronized 可以用于对代码块或方法进行修饰， 而不能够用于对class 以及变量进行修饰。
  
[Synchronize实现原理（很难）](https://blog.csdn.net/zbuger/article/details/51030772)

</details>



<details>
<summary>深入JVM锁机制1-synchronized</summary>

[深入JVM锁机制1-synchronized](https://blog.csdn.net/chen77716/article/details/6618779)

</details>

<details>
<summary>深入JVM锁机制2-Lock</summary>

[深入JVM锁机制2-Lock](https://blog.csdn.net/chen77716/article/details/6641477)

</details>

<details>
<summary>synchronized与static synchronized 的区别</summary>

[synchronized与static synchronized 的区别](https://blog.csdn.net/zhongwen7710/article/details/40057071)

</details>


<details>
<summary>Java中的ReentrantLock和synchronized两种锁定机制的对比</summary>

[Java中的ReentrantLock和synchronized两种锁定机制的对比](https://blog.csdn.net/fw0124/article/details/6672522)

</details>


<details>
<summary>自旋锁</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>


<details>
<summary>偏向锁</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>Cache命中缺失</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>Cache一致性流量</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>本地延迟</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>对称多处理器架构(SMP)和非对称多处理器架构(Non Uniform Memory Access Achitecture)</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>CAS(Compare-And-Swap)</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>CAS(Compare-And-Swap)</summary>

[Synchronized的JVM底层实现](https://blog.csdn.net/Winston_Limf/article/details/80915304)

</details>

<details>
<summary>轻量级锁</summary>

* [JVM 中synchronized的底层实现原理解析](https://blog.csdn.net/HinstenyHisoka/article/details/80864378)

</details>

<details>
<summary>重量级锁</summary>

* [JVM 中synchronized的底层实现原理解析](https://blog.csdn.net/HinstenyHisoka/article/details/80864378)

</details>

<details>
<summary>锁的升级, 降级</summary>
  
* [JVM 中synchronized的底层实现原理解析](https://blog.csdn.net/HinstenyHisoka/article/details/80864378)

</details>

<details>
<summary>Java 多线程全局锁与对象锁</summary>

[Java 多线程全局锁与对象锁](https://blog.csdn.net/weixin_40739833/article/details/80293480)

</details>

<details>
<summary>ReentrantLock</summary>

[ReentrantLock解析](https://blog.csdn.net/yanlinwang/article/details/40450769)

</details>

---

<details>
<summary>ReentrantReadWriteLock</summary>


</details>

<details>
<summary>StampedLock</summary>


</details>

<details>
<summary>锁膨胀</summary>


</details>


<details>
<summary>锁粗化（Lock Coarsening）</summary>
  
也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁

</details>

<details>
<summary>锁消除（Lock Elimination）</summary>
  
通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本地Stack上进行对象空间的分配（同时还可以减少Heap上的垃圾收集开销）

</details>

<details>
<summary>锁消除（Lock Elimination）</summary>
  
通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本地Stack上进行对象空间的分配（同时还可以减少Heap上的垃圾收集开销）

</details>

<details>
<summary>适应性自旋（Adaptive Spinning）</summary>
  
当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁（mutex semaphore）前会进入忙等待（Spinning）然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore（即互斥锁）进入到阻塞状态。

</details>


1.有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?

2.高并发情况下，我们系统是如何支撑大量的请求的

3.集群如何同步会话状态

4.负载均衡的原理

5.如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）

6.如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。

7.假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。

8.如何查找造成性能瓶颈出现的位置，是哪个位置照成性能瓶颈。

9.你的项目中使用过缓存机制吗？有没用用户非本地缓存



# 有用的

* [电商那些年，我摸爬打滚出的高并发架构实战精髓](https://blog.csdn.net/u010327957/article/details/52788068)
