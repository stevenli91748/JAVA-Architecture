
**内存模型”一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而Java 虚拟机也有自己的内存模型，Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（ Variables ）与Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的e，不会被共享，自然就不会存在竞争问题。**

<a href="https://ibb.co/tpDDSYq"><img src="https://i.ibb.co/KxWWYV2/JMM.png" alt="JMM" border="0"></a>

* [主内存与工作内存](#主内存与工作内存)
  * [内存间交互操作](#内存间交互操作)
  * [Volatile](#Volatile)
  * [Synchronized](#Synchronized)
* 线程


## 主内存与工作内存

    Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（ Variables ）与Java 编程中所说的变量有所区别，它包括了实例
    字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的e，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能， Java 内存模型并没有限制执行引擎使用处理器
    的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。Java 内存模型规定了所有的变量都存储在主内存（ Main Memo叩）中（此处的主内存与介绍物理硬件时的主内
    存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分〉。每条线程还有自己的工作内存（ Working Memory ，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的
    主内存副本拷贝。，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量气不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内
    存来完成，这里所讲的主内存、工作内存与本书第2 章所讲的Java 内存区域中的Java 堆、枝、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主
    内存、工作内存的定义来看，主内存主要对应于Java 堆中的对象实例数据部分θ，而工作内存则对应于虚拟机校中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚
    拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。

### 内存间交互操作
   
  关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节， Java 内存模型中定义了以下8 种操作来完成

    1. lock （锁定〉：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
    2. unlock C 解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
    3. read C 读取） ： 作用于主内存的变量， 它把一个变量的值从主内存传输到线程的工作内存中，以便随后的l oad 动作使用。
    4. load （载入） ： 作用于工作内存的变量，它把read 操作从主内存中得到的变量值放入工作内存的变量副本中。
    5. use C 使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
    6. assign （赋值） ： 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
    7. store C 存储〉： 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write 操作使用。
    8. write （写入）：作用于主内存的变量，它把store 操作从工作内存中得到的变量的值放人主内存的变量中。

    如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read 和l load 操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store 和write 操作。注意， Java 内存模型只要求上述两个操作
    必须按顺序执行，而没有保证是连续执行。也就是说， read 与load之间、store 与write 之间是可插入其他指令的，如对主内存中的变量a 、b 进行访问时，一种可能出现顺序是read a, read b 、
    load b 、load a 。除此之外， Java 内存模型还规定了在执行上述8 种基本操作时必须满足如下规则：
    
    1. 不允许read 和load 、store 和write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
    2. 不允许一个线程丢弃它的最近的assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
    3. 不允许一个线程无原因地（没有发生过任何assign 操作）把数据从线程的工作内存同步回主内存中。
    4.  一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（ load 或assign ）的变量，换句话说，就是对一个变量实施use 、store 操作之前，必须先执行过了assign 和load 
       操作。
    5. 一个变量在同一个时刻只允许一条线程对其进行lock 操作，但lock 操作可以被同一条线程重复执行多次，多次执行lock 后，只有执行相同次数的unlock 操作，变量才会被解锁。
    6. 如果对一个变量执行l ock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load 或ass ign 操作初始化变量的值。
    7. 如果一个变量事先没有被lock 操作锁定，那就不允许对它执行unlock 操作，也不允许去unlock 一个被其他线程锁定住的变量。
    8. 对一个变量执行unlock 操作之前，必须先把此变量同步回主内存中（执行store 、write操作）。

## 内存交互基本操作的 3 个特性

  Java 内存模型是围绕着在并发过程中如何处理这 3 个特性来建立的.

  原子性(Atomicity):

            原子性，即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。
            
  可见性(Visibility):

           可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。正如上面“交互操作流程”中所说明的一样，JMM 是通过在线程 1 变量工作内存修改
           后将新值同步(store,write)回主内存，线程 2 在变量读取前从主内存刷新(read,load)变量值，将主内存作为传递媒介的方式来实现可见性。
           
           多个线程之间是不能互相传递数据通信的，它们之间的沟通只能通过共享变量来进行。Java内存模型(JMM)规定了jvm有主内存，主内存是多个线程共享的。当new一个对象的时候，也是
           被分配在主内存中，每个线程都有自己的工作内存，工作内存存储了主存的某些对象的副本，当然线程的工作内存大小是有限制的。
           
           共享变量可见性实现的原理：

           线程1对共享变量的修改要想被线程2及时看到，必须要经过如下几个步骤：

                  将工作内存1中更新过的共享变量更新到主内存中(store-write)
                  将主内存中最新的共享变量的值更新到工作内存2中(read-load)

           当线程操作某个对象时，执行顺序如下：

                  从主存复制变量到当前工作内存 (read(读取)-load(加载))
                  执行代码，改变共享变量值 (use(使用)-assign(赋值))
                  用工作内存数据刷新主存相关内容 (store(存储)-write(写入))
                  当一个共享变量在多个线程的工作内存中都有副本时，如果一个线程修改了这个共享变量，那么其他线程应该能够看到这个被修改后的值，这就是多线程的可见性问题 。 
                  java中volatile解决了可见性问题
      
  有序性(Ordering):

           在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性

          多个线程执行时，CPU对线程的调度是随机的，我们不知道当前程序被执行到哪步就切换到了下一个线程
          线程在引用变量时不能直接从主内存中引用 , 如果线程工作内存中没有该变量 , 则会从主内存中拷贝一个副本到工作内存中,这个过程为(read(读取)-load()加载),完成后线程会引用该副本，
          线程不能直接为主存中字段赋值，它会将值指定给工作内存中的变量副本(assign(赋值)),完成后这个变量副本会同步到主存储区进行(store(存储)-write(写入))操作，至于何时同步过去，根据JVM
          实现系统决定。
          
          这里看一个最经典的例子就是银行汇款问题：

              一个银行账户存款100，这时一个人从该账户取10元，同时另一个人向该账户汇10元，那么余额应该还是100。
              那么此时可能发生这种情况，A线程负责取款，B线程负责汇款，A从主内存读到100，B从主内存读到100，A执行减10操作，并将数据刷新到主内存，这时主内存数据100-10=90，而B内存执行加
              10操作，并将数据刷新到主内存，最后主内存数据100+10=110，显然这是一个严重的问题，我们要保证A线程和B线程有序执行，先取款后汇款或者先汇款后取款。


             这里将一个非原子操作进行分解分步说明: 假设有一个共享变量 x，线程Thread1 执行 x=x+1 。从上面的描述中可以知道 x=x+1 并不是一个原子操作，它的执行过程如下：

             从主存中读取变量x副本到工作内存
             给x加1
             将x加1后的值写回主存
             如果另外一个线程b执行x=x-1，执行过程如下：

             从主存中读取变量x副本到工作内存
             给x减1
             将x减1后的值写回主存
             那么显然，最终的x的值是不可靠的。假设x现在为10，线程a加1，线程b减1，从表面上看，似乎最终x还是为10，但是多线程情况下会有这种情况发生：

             线程a从主存读取x副本到工作内存，工作内存中x值为10
             线程b从主存读取x副本到工作内存，工作内存中x值为10
             线程a将工作内存中x加1，工作内存中x值为11
             线程a将x提交主存中，主存中x为11
             线程b将工作内存中x值减1，工作内存中x值为9
             线程b将x提交到中主存中，主存中x为9,同样，x有可能为11，每次执行的结果都是不确定的，因为线程的执行顺序是不可预见的。这是java同步产生的根源，synchronized关键字保证了多个线程对
             于同步块是互斥的，synchronized作为一种同步手段，解决java多线程的执行有序性和内存可见性，而volatile关键字之解决多线程的内存可见性问题



## Volatile
   
   volatile是java提供的一种同步手段，只不过它是轻量级的同步，为什么这么说，因为volatile只能保证多线程的内存可见性，不能保证多线程的执行有序性。而最彻底的同步要保证有序性和可见性
   例如synchronized。

   任何被volatile修饰的变量，都不拷贝副本到工作内存(read-load)，任何修改都及时写在主存。因此对于volatile修饰的变量的修改，所有线程马上就能看到，但是volatile不能保证对变量的修改是有序的


<a href="https://ibb.co/qjM4xvY"><img src="https://i.ibb.co/Gpv1FqQ/JMM-1.png" alt="JMM-1" border="0"></a>

使用Volatile后：

<a href="https://ibb.co/QPqXDHh"><img src="https://i.ibb.co/R3M7j6t/JMM-2.png" alt="JMM-2" border="0"></a>


## Synchronized

    java用synchronized关键字做为多线程并发环境的执行有序性的保证手段之一。当一段代码会修改共享变量，这一段代码成为互斥区或临界区，为了保证共享变量的正确性，synchronized标示了临界区。
    典型的用法如下

    为了保证银行账户的安全，可以操作账户的方法如下：

     public synchronized void add(int putMoney) {  
         money = money+ putMoney;  
     }  

     public synchronized void minus(int getMoney) {  
          money = money - getMoney;  
     }  

     那么对于public synchronized void add(int putMoney)这种情况，意味着什么呢？其实这种情况，锁就是这个方法所在的对象。同理，如果方法是public static synchronized void add
     (int putMoney)，那么锁就是这个方法所在的class
  
     理论上，每个对象都可以做为锁，但一个对象做为锁时，应该被多个线程共享，这样才显得有意义，在并发环境下，一个没有共享的对象作为锁是没有意义的. 假如有这样的代码：
  
      public class ThreadTest{  
      public void test(){  
         Object lock=new Object();  
         synchronized (lock){  
            //do something  
         }  
      }  
    }  

    lock变量作为一个锁存在根本没有意义，因为它根本不是共享对象，每个线程进来都会执行Object lock=new Object(); 每个线程都有自己的lock，根本不存在锁竞争。

     每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程，当一个被线程被唤醒(notify)后，才会进入到就绪队列，等待cpu的调度。
     当一开始线程a 第一次执行account.add方法时，jvm会检查锁对象account的就绪队列是否已经有线程在等待，如果有则表明account的锁已经被占用了，由于是第一次运行，account的就绪队列为空，所以
     线程a获得了锁，执行account.add方法。如果恰好在这个时候，线程b要执行account.minus方法，因为线程a已经获得了锁还没有释放，所以线程b要进入account的就绪队列，等到得到锁后才可以执行。
     一个线程执行临界区代码过程如下：

         获得同步锁
         清空工作内存
         从主内存拷贝变量的最新副本到工作内存(read(读取)-load(加载))
         执行代码(use(使用)-assign(赋值))
         将更改后的共享变量的值刷新到主内存(store(存储)-write(写入))
         释放锁


# 有用的参考

* [【Java多线程】主内存与工作内存分析](https://blog.csdn.net/qq877728715/article/details/101547608)
