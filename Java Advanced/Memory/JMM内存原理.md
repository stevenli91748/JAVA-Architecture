# JMM主要操作

Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性来建立的(三个特性详解见10.)
a.Java内存模型将内存分为了主内存和工作内存
b.Java内存模型规定所有的变量都存储在主内存中，每个线程有自己的工作内存
c.主内存主要包括：堆和方法区，主内存是所有线程共享的
d.工作内存主要包括：该线程私有的栈和对主内存部分变量拷贝的寄存器（包括程序计数器和cpu高速缓存区)
e.Java内存模型规定了所有变量都存储在主内存中，每个线程有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接读写主内存中的变量，不同线程之间也无法直接操作对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成，

# JAVA 内存交互协议
  JAVA 内存模型定义了八种操作来完成主内存和工作内存的变量访问
  
  1. lock：主内存变量，把一个变量标识为某个线程独占的状态；

  2. unlock：主内存变量，把一个处于锁定状态变量释放出来，被释放后的变量才可以被其它线程锁定；

  3. read：主内存变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load 动作使用；

  4. load：工作内存变量，把read 读取到的主内存中的变量值放入工作内存的变量拷贝中；

  5. use：工作内存变量，把工作内存中变量的值传递给java 虚拟机执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行该操作；

  6. assign：工作内存变量，把从执行引擎接收到的变量的值赋值给工作变量，每当虚拟机遇到一个给变量赋值的字节码时将会执行该操作；
  
  7. store：工作内存变量，把工作内存中一个变量的值传送到主内存中，以便随后的write 操作使用；

  8. write：主内存变量，把store 操作从工作内存中得到的变量值放入主内存的变量中。
  

# JMM可见性
  在Java内存模型中，如果一个线程更改了共享变量的值，其他线程能马上知道这个更改，则我们说这个变量具有可见性。一般来说有四种方式能保证变量的可见性，分别为volatile、synchronized、final和
  锁。

  首先谈谈volatile，被此关键词声明的变量，每当有任何更改时都将立即同步到主存中，而每个线程要使用这个变量时都要重新从主存刷新到工作内存，这样就确保了变量的可见性。当然，普通变量最终也会
  同步到主存，再由主存同步到每个线程的工作内存，只是这个最终可能比较“长久”，不能保证可见性。

 其次，关于synchronized，由于synchronized底层也是通过锁进行实现，所以synchronized和锁的本质是一样的。当一个线程释放一个锁时，将会强制刷新工作内存中的变量值到主存中。而当另一个线程获
 取此锁的时候将会强制重新装载此变量值。当然这两个线程获取的是同一个锁，这样就保证了变量的可见性。

 最后，被final声明的变量一旦完成初始化，其他线程就能看到这个final变量。其实，可见性其实可以看成是一种机制，线程在进入/退出同步块程序时，它将发送/接收一个变量的更改。

# JMM有序性
  有序性指在线程内看方法的执行，所有的指令都是有序的，都按照一种串行方式执行。而在线程内观察其他线程，所有指令都是无序的，指令都可能交叉执行。Java中提供了volatile和synchronized两个关
  键词保证线程之间操作的有序性，而这个有序性仅仅是相对的，volatile禁止指令重排序，synchronized则保证持有同一个锁的同步块只能串行运行。

# JMM原子性
  Java内存模型保证了read、load、assign、use、store、write等操作具有原子性，我们可以认为除了long和double类型外，对其他基本数据类型所对应的内存单元的访问读写都是原子的。但由于这个原子
  性的颗粒度太小，通常情况下我们需要更大颗粒度的原子性，这时就需要用锁来保证了。
