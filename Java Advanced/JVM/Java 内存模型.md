
**内存模型”一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而Java 虚拟机也有自己的内存模型，Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（ Variables ）与Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的e，不会被共享，自然就不会存在竞争问题。**

* 主内存与工作内存
  * 内存间交互操作
* 线程


## 主内存与工作内存

    Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（ Variables ）与Java 编程中所说的变量有所区别，它包括了实例
    字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的e，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能， Java 内存模型并没有限制执行引擎使用处理器
    的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。Java 内存模型规定了所有的变量都存储在主内存（ Main Memo叩）中（此处的主内存与介绍物理硬件时的主内
    存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分〉。每条线程还有自己的工作内存（ Working Memory ，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的
    主内存副本拷贝。，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量气不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内
    存来完成，这里所讲的主内存、工作内存与本书第2 章所讲的Java 内存区域中的Java 堆、枝、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主
    内存、工作内存的定义来看，主内存主要对应于Java 堆中的对象实例数据部分θ，而工作内存则对应于虚拟机校中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚
    拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。

### 内存间交互操作
   
  关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节， Java 内存模型中定义了以下8 种操作来完成

    1. lock （锁定〉：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
    2. unlock C 解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
    3. read C 读取） ： 作用于主内存的变量， 它把一个变量的值从主内存传输到线程的工作内存中，以便随后的l oad 动作使用。
    4. load （载入） ： 作用于工作内存的变量，它把read 操作从主内存中得到的变量值放入工作内存的变量副本中。
    5. use C 使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
    6. assign （赋值） ： 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
    7. store C 存储〉： 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write 操作使用。
    8. write （写入）：作用于主内存的变量，它把store 操作从工作内存中得到的变量的值放人主内存的变量中。

    如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read 和l load 操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store 和write 操作。注意， Java 内存模型只要求上述两个操作
    必须按顺序执行，而没有保证是连续执行。也就是说， read 与load之间、store 与write 之间是可插入其他指令的，如对主内存中的变量a 、b 进行访问时，一种可能出现顺序是read a, read b 、
    load b 、load a 。除此之外， Java 内存模型还规定了在执行上述8 种基本操作时必须满足如下规则：
    
    1. 不允许read 和load 、store 和write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
    2. 不允许一个线程丢弃它的最近的assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
    3. 不允许一个线程无原因地（没有发生过任何assign 操作）把数据从线程的工作内存同步回主内存中。
    4.  一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（ load 或assign ）的变量，换句话说，就是对一个变量实施use 、store 操作之前，必须先执行过了assign 和load 
       操作。
    5. 一个变量在同一个时刻只允许一条线程对其进行lock 操作，但lock 操作可以被同一条线程重复执行多次，多次执行lock 后，只有执行相同次数的unlock 操作，变量才会被解锁。
    6. 如果对一个变量执行l ock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load 或ass ign 操作初始化变量的值。
    7. 如果一个变量事先没有被lock 操作锁定，那就不允许对它执行unlock 操作，也不允许去unlock 一个被其他线程锁定住的变量。
    8. 对一个变量执行unlock 操作之前，必须先把此变量同步回主内存中（执行store 、write操作）。
