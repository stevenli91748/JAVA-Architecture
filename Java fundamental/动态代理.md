

[JDK、CGLIB动态代理使用以及源码分析](https://bugstack.cn/itstack-demo-any/2019/12/21/%E6%9C%89%E7%82%B9%E5%B9%B2%E8%B4%A7-JDK-CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html)|
---|

# 视频

* [java class 动态代理本质 2019](https://www.bilibili.com/video/av56887858/?spm_id_from=333.788.videocard.1)
* [阿里资深Java架构师一堂课带你吃透动态代理，解密SpringAOP源码](https://www.bilibili.com/video/av53844538/?spm_id_from=333.788.videocard.0)
* [JAVA JDK 动态代理源码解析](https://www.bilibili.com/video/av58742137/?spm_id_from=333.788.videocard.12)


# 目录

动态代理（Dynamic Proxy）是一种在运行时生成代理对象的技术，它允许你在不修改源代码的情况下，在方法调用前后添加额外的逻辑。Java提供了两种方式实现动态代理：基于接口的动态代理和基于类的动态代理。下面我将分别介绍这两种方式的使用方法。

1. 基于接口的动态代理：
基于接口的动态代理要求目标对象必须实现一个接口。使用java.lang.reflect.Proxy类创建动态代理对象。以下是使用基于接口的动态代理的步骤：

创建一个实现InvocationHandler接口的代理处理器类，该接口中有一个方法invoke，它负责处理代理对象的方法调用并添加额外逻辑。

``java

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class MyInvocationHandler implements InvocationHandler {
    private Object target;

    public MyInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 在方法调用前添加额外逻辑
        System.out.println("Before method invocation");

        // 调用目标对象的方法
        Object result = method.invoke(target, args);

        // 在方法调用后添加额外逻辑
        System.out.println("After method invocation");

        return result;
    }
}

``






# 有用的参考

 * [动态代理](https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984)
