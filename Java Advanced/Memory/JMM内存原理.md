# JMM主要操作

Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性来建立的(三个特性详解见10.)
a.Java内存模型将内存分为了主内存和工作内存
b.Java内存模型规定所有的变量都存储在主内存中，每个线程有自己的工作内存
c.主内存主要包括：堆和方法区，主内存是所有线程共享的
d.工作内存主要包括：该线程私有的栈和对主内存部分变量拷贝的寄存器（包括程序计数器和cpu高速缓存区)
e.Java内存模型规定了所有变量都存储在主内存中，每个线程有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接读写主内存中的变量，不同线程之间也无法直接操作对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成，


  JMM定义了八个主要的内存操作来完成工作内存与主存的通信。假如一条线程准备对一个变量进行新的赋值操作，它可能会先用lock操作锁住主内存中的某个变量，不让其他线程获得此变量的锁，
  直至使用unlock操作释放该变量的锁。接着使用read操作将变量从主存读到工作内存中，紧接着load操作将得到的变量值放到工作内存中的变量副本。use操作则将变量值传给线程执行引擎进行运算操作，
  assign操作把新的变量值从线程执行引擎中传递到工作内存。store操作则把变量值从工作内存传送到主存中，接着write操作将得到的值写入主存相应的变量中，最后使用unlock操作释放变量的锁。

# JMM可见性
  在Java内存模型中，如果一个线程更改了共享变量的值，其他线程能马上知道这个更改，则我们说这个变量具有可见性。一般来说有四种方式能保证变量的可见性，分别为volatile、synchronized、final和
  锁。

  首先谈谈volatile，被此关键词声明的变量，每当有任何更改时都将立即同步到主存中，而每个线程要使用这个变量时都要重新从主存刷新到工作内存，这样就确保了变量的可见性。当然，普通变量最终也会
  同步到主存，再由主存同步到每个线程的工作内存，只是这个最终可能比较“长久”，不能保证可见性。

 其次，关于synchronized，由于synchronized底层也是通过锁进行实现，所以synchronized和锁的本质是一样的。当一个线程释放一个锁时，将会强制刷新工作内存中的变量值到主存中。而当另一个线程获
 取此锁的时候将会强制重新装载此变量值。当然这两个线程获取的是同一个锁，这样就保证了变量的可见性。

 最后，被final声明的变量一旦完成初始化，其他线程就能看到这个final变量。其实，可见性其实可以看成是一种机制，线程在进入/退出同步块程序时，它将发送/接收一个变量的更改。

# JMM有序性
  有序性指在线程内看方法的执行，所有的指令都是有序的，都按照一种串行方式执行。而在线程内观察其他线程，所有指令都是无序的，指令都可能交叉执行。Java中提供了volatile和synchronized两个关
  键词保证线程之间操作的有序性，而这个有序性仅仅是相对的，volatile禁止指令重排序，synchronized则保证持有同一个锁的同步块只能串行运行。

# JMM原子性
  Java内存模型保证了read、load、assign、use、store、write等操作具有原子性，我们可以认为除了long和double类型外，对其他基本数据类型所对应的内存单元的访问读写都是原子的。但由于这个原子
  性的颗粒度太小，通常情况下我们需要更大颗粒度的原子性，这时就需要用锁来保证了。
